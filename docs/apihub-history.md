# Qubership Apihub Project History

## Short Description
Apihub is an API management system focused on specification analysis and comparison.

## Reason to Develop a New System
There are many API management systems on the market, but most of them are focused on API development, storage, and display.  
The project was started because there was no system on the market that satisfied the company's needs to process and analyze complex specifications.

In general, there was a desire to store all specifications in one system.  
One of the use cases was to dereference complex specifications with cyclic external references (all tested systems failed).  
Another requirement was related to comparing the issued release version’s APIs, and we found no suitable solution.

## API Development Approaches
Before diving into the history of Apihub, let’s review the main API development approaches.

### API-First
* Requirements are described in some document or ticket.
* The API is developed as a prerequisite for code changes. 
* When the API is ready, the code is implemented manually following the specification or auto-generated.

### Code-First
* Requirements are described in some document or ticket.
* The code implements the requirement.
* The specification is generated by the framework.

## The Beginning

### Portal and Editor
Apihub started as a simple file (spec) storage with the ability to view specifications (via Stoplight’s library).  
From the beginning, there was a hypothesis that the API-first approach was the preferable one.  
The next stage of Apihub was an online editor (based on the Monaco editor from VS Code).  
It then supported viewing the contents of a Git repository, adding/editing specification files, committing changes, and publishing them to the portal.  
As an improvement to this idea, collaborative editing support was added (based on WebSockets and operational transformation).

At that moment, the only way to create a new version was via the editor.

### Comparison
The next goal was to enable comparison between versions (or revisions) with change classification.  
It was implemented via the API-smart-diff (JS) library (see Golang vs JavaScript comparison).  
“Effective changes” were selected as a diff policy — i.e., it shows how a change in the specification affects all operations inside it.  
The specification file is dereferenced first, and then the diff is calculated.  
For example, if some object schema is modified, the changes are propagated to every operation that includes that schema.

## Problems
After the initial implementation, we faced the following problems:

1) **Comparison problems**  
* Since a service’s API may contain multiple files, some operations/models could be moved between files during refactoring.  
* OpenAPI and other standards support external references, i.e., a specification can be divided into multiple files. Some operations/models could be moved between files, extracted into separate files, or files could be merged.  
In these cases, the API itself is not changed, but the text files are modified. Such cases break simple text diffs between specification files.

2) **Rendering performance problems**  
Some large specifications caused rendering problems in Stoplight’s library.  
The UI became slow and unresponsive, and simply transferring a spec of ~5 MB took a significant amount of time.

## New Concept of "Operation"
As a response to these problems, we generated the following ideas:
* A service’s API is the sum of all specs.
* An API spec is the sum of the operations inside it.
* An operation should include all required schemas and be self-descriptive.

(An operation is the minimal correct specification of the API type.)

So, version comparison becomes a comparison of operation sets.  

The operations concept resolves all refactoring cases because the comparison works over generated data (operations), and the original placement of text in files doesn’t matter.  
A UI approach to render an operations list plus any single operation separately also resolves the performance problem.

### Build Process
At this point, we introduced a `build` concept.  
A `build` is a set of operations executed on the “build task consumer” service or UI. The backend service handles the queue.  

Builds have different types: 
* changelog — generate changelog
* build — publish version
* exportVersion — export package version
* exportRestDocument — export OpenAPI document
* exportRestOperationsGroup — export operation group

A build of type `build` (version publish) includes the following steps (... TODO).  

It is required to produce derived data from the user’s sources.

TODO: client-side build details  
By default, the UI runs the client build process, but the “build task consumer” is ready to take over the build.

### Migration to "Operations"
When the operation-centric approach was implemented, we planned a one-time migration from the document-centric approach.  
But it turned out that the operation generation mechanism was not perfect and required continuous improvements and fixes.  
That’s how operations migration became a routine (see operations migration article for more details).  
Any change in the “builder” library requires running a migration.

## Code-First Support via Agent
Meanwhile, it turned out that many users preferred the code-first approach over API-first.  
This means that the code is implemented first, and the API spec is generated during compilation or at runtime.  
At that moment, Apihub had no convenient way to support such an approach.

The **Agent** was the answer to this problem.  
The Agent performs specification discovery in a selected Kubernetes environment.  
It sends requests to a preconfigured list of URLs to find exposed specifications.

TODO: runenv  
TODO: how pkg is bound to service  
TODO: discovery, snapshot, promote  

------

Part of the system (an extension) was designed to receive discovered specifications from the Agent and publish them to the portal.  
Thus, the code-first approach was successfully supported.

## Quality Gate Extension (TODO: remove from public doc)
API quality is a procedure to ensure that every new release version of every product API is published to Apihub and that it introduces no breaking changes.  
Breaking changes are allowed only if they follow the policy:  
A deprecated (!) operation can legally be deleted only after two release versions in a deprecated state.

## Multiple Specification Types Support
From the beginning, Apihub was designed to support multiple specification types.  
The first goal was OpenAPI.  

The next goals were AsyncAPI, GraphQL, and gRPC.

## Comparison Optimization
Initially, the comparison operation was performed online in the browser right before rendering, which caused performance problems for large and complex specifications.  
At the same time, the comparison between a version and the previous version was calculated during the build procedure, but the results (other than the summary) were not retained.  
So, we decided to store the comparison results in the DB as a cache.  

### Effective Changes to Declarative Changes
TODO

### GQL support rethinking
TODO

## Editor removal, VSCode plugin implementation
TODO

## BE architecture: APIHUB extensions concept
TODO
