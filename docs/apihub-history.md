# Qubership Apihub project history

## Short description
Apihub is an API management system with focus on specification analysis and comparison.

## Reason to develop new system
There are a lot of API management systems on the market, but most of them are focused on API development, storage and display.  
The project was started because there was no system on the market that satisfied company's needs to process and analyze complex specifications.

In general there was a will to store all specifications in one system.
But one of the cases was to make a dereference for a complex specifications with cyclic external reference(all tested systems failed).
Another requirement was related to comparison of the issued release version's APIs and we found no suitable solution.

## API development approaches
Before diving into Apihub history description, let's study the API development approaches.

### API first
* Requirements described in some document/ticket.
* The API is developed as a pre-requisite for code changes. 
* When API is ready, the code is implemented manually following the specification or auto-generated.

### Code first
* Requirements described in some document/ticket.
* The code implements the requirement
* The specification is generated by framework.

## The beginning

### Portal and Editor
Apihub started as a simple file(spec) storage with an ability to view the specifications(via Stoplight's library).  
From the beginning there was a hypothesis that API first approach is the preferable one.
So the next stage of Apihub was online editor (based on Monaco editor from VS code).
Then supported viewing content of git repo, add/edit specification files, commit changes and publish to the portal.
As an improvement of this idea was collaboration editing support(based on websockets and operational transformation).

At this moment, the only way to create a new version was "editor".

### Comparison
The next goal was comparison between versions(or revisions) with changes classification.
It was implemented via API-smart-diff(js) library. (See golang vs javascript comparison)
"Effective changes" were selected as a diff policy, i.e. it shows how a change in specification affects all operations inside it.
Specification file is dereferenced first and then the diff is calculated. 
For example if some object schema is modified, the changes will be propagated to every operation that includes the schema.

## Problems
After the initial implementation we've faced the following problems:
1) comparison problems
* since service's API may contain multiple file, some operations/models could be moved between files in refactoring purpose.
* Openapi and other standards support external references, i.e. specification is divided into multiple files. Some operations/models could be moved between files, extracted into separate files, files could be merged. 
In this cases API itself is not changed, but the text files are modified. So this cases break simple text diff between specification files.

2) rendering performance problems
Some big specifications caused rendering problems in the Stoplight's library. UI became was slow and unresponsive as well as just transferring a spec like 5mb big takes decent amount of time.

## New concept of "operation"
As a response the problems we've generated the following ideas:
* Service's API is a sum of all specs.
* API spec is a sum of operations inside it.
* Operation should include all required schemas and be self-descriptive.

(operation is a minimal correct specification of the API type)

So versions comparison is a comparison of operation sets. 

The operations concept is fixing all refactoring cases because the comparison works over generated data(operations) and original place of the text in files doesn't matter.
UI approach to render operations list plus any single operation separately resolves the performance problem.

### Build process
At this point we've introduced a `build` concept.
`Build` is a set of operations executed on "build task consumer" service or UI. The backend service handles the queue.
Build have different types: 
* changelog - generate changelog
* build - publish version
* exportVersion - export package version
* ExportRestDocument - export Openapi document
* ExportRestOperationsGroup - export operation group

Build of type "build"(version publish) includes the following steps (... TODO) 

it's required to produce derived data from the sources from user.

TODO: client side build details  
By default UI runs client build process, but "build task consumer" is ready to take over the build.

### Migration to "operations"
When the operation-centric approach was implemented, we planned single time migration from the document-centric approach.
But it turned out that operation generation mechanism was not perfect and required continuous improvements and fixes.
That's how operations migration became a routine. (See operations migration article for more details)
Any change in "builder" library requires to run a migration.

## Code-first support via Agent

Meanwhile, it's turned out that many users prefer code-first approach, not API-first.
It means that the code is implemented first and the API spec is generated during the compilation or in runtime.
And on those moment Apihub had no convenient was to support such approach.

"Agent" was an answer to this problem.
Agent performs specifications discovery in selected Kubernetes environment.
It sends requests to pre-configured list of URLs to find exposed specifications.

TODO: runenv 
TODO: how pkg is bound to service

TODO: discovery, snapshot, promote

------

Part of the system(extension) was designed to get discovered specifications from agent and publish it to the portal.
So the code-first approach was successfully supported.

## Quality gate extension (TODO: remove from public doc)

Quality gate (extension)
API quality is a procedure to make sure that every new release version of every product API is published to the Apihub and it introduces no breaking changes. 
Breaking changes are allowed only if they follow the policy:
Deprecated(!) operation could be legally deleted only after two (release) versions being deprecated.




## Multiple specification types support

From the beginning Apihub was designed to support multiple specification types.
The first goal was Openapi 

The next goals are Asyncapi, Graphql, GRPC.


## Comparison optimization
Initially, comparison operation was performed online in browser, right before the rendering. Which caused performance problems for big and complex specifications.
Same time, the comparison between version and previous version was calculated during the build procedure. But the results (other than summary) was not retained.
So we decided to store the comparison results in DB as a cache. 

### Effective changes to declarative changes
TODO

